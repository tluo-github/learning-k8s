# 记一次KUBERNETES/DOCKER网络排障

**案例来源:** https://coolshell.cn/articles/18654.html

** 问题的症状:**
用户直接在微信里说，他们发现在Kuberbnetes下的某个pod被重启了几百次甚至上千次，于是开启调查这个pod，发现上面的服务时而能够访问，时而不能访问，也就是有一定概率不能访问，不知道是什么原因。而且并不是所有的pod出问题，而只是特定的一两个pod出了网络访问的问题。用户说这个pod运行着Java程序，为了排除是Java的问题，用户用 **docker exec -it** 命令直接到容器内启了一个 Python的 SimpleHttpServer来测试发现也是一样的问题。

** 问题初查 **

首先，我们排除了flannel的问题，因为整个集群的网络通信都正常，只有特定的某一两个pod有问题。而用 **telnet ip port** 的命令手工测试网络连接时有很大的概率出现 **connection refused** 错误，大约 1/4的概率，而3/4的情况下是可以正常连接的。

当时，我们让用户抓个包看看，然后，用户抓到了有问题的TCP连接是收到了 SYN 后，立即返回了 **RST, ACK**

![](/images/case-2-tcpdump.png)

我问一下用户这两个IP所在的位置，知道了，**10.233.14.129** 是 **docker0**，**10.233.14.145** 是容器内的IP。所以，这基本上可以排除了所有和kubernets或是flannel的问题，这就是本地的Docker上的网络的问题。

对于这样被直接 Reset 的情况，在 **telnet** 上会显示 **connection refused** 的错误信息，对于我个人的经验，这种 **SYN** 完直接返回 **RST, ACK** 的情况只会有三种情况：

1. TCP链接不能建立，不能建立连接的原因基本上是标识一条TCP链接的那五元组不能完成，绝大多数情况都是服务端没有相关的端口号。
2. TCP链接建错误，有可能是因为修改了一些TCP参数，尤其是那些默认是关闭的参数，因为这些参数会导致TCP协议不完整。
3. 有防火墙iptables的设置，其中有 **REJECT** 规则。(也就是一条 ICMP 回复)

** 重新梳理 **

用户提供了一个比较关键的信息—— “抓包这个事，在 **docker0** 上可以抓到，然而到了容器内抓不到容器返回 RST, ACK ” ！然而，根据我的知识，我知道在 **docker0 ** 和容器内的 **veth** 网卡上，中间再也没有什么网络设备了

于是这个事把我们逼到了最后一种情况 —— IP地址冲突了！

Linux下看IP地址冲突还不是一件比较简单事的，而在用户的生产环境下没有办法安装一些其它的命令，所以只能用已有的命令，这个时候，我们发现用户的机器上有 **arping** 于是我们用这个命令来检测有没有冲突的IP地址。使用了下面的命令：

```shell
$ arping -D -I docker0 -c 2 10.233.14.145
$ echo $?
```

根据文档，**-D** 参数是检测IP地址冲突模式，如果这个命令的退状态是 **0** 那么就有冲突。结果返回了 **1** 。而且，我们用 **arping** IP的时候，没有发现不同的mac地址。 这个时候，似乎问题的线索又断了。

** 柳暗花明 **

现在我们知道，IP冲突的可能性是非常大的，但是我们找不出来是和谁的IP冲突了。而且，我们知道只要把这台机器重启一下，问题一定就解决掉了，但是我们觉得这并不是解决问题的方式，因为重启机器可以暂时的解决掉到这个问题，而如果我们不知道这个问题怎么发生的，那么未来这个问题还会再来。而重启线上机器这个成本太高了。


于是，我们的好奇心驱使我们继续调查。我让用户 **kubectl delete** 其中两个有问题的pod，因为本来就服务不断重启，所以，删掉也没有什么问题。删掉这两个pod后（一个是IP为 **10.233.14.145** 另一个是 **10.233.14.137**），我们发现，kubernetes在其它机器上重新启动了这两个服务的新的实例。然而，在问题机器上，这两个IP地址居然还可以ping得通。

好了，IP地址冲突的问题可以确认了。因为**10.233.14.xxx** 这个网段是 docker 的，所以，这个IP地址一定是在这台机器上。所以，我们想看看所有的 network namespace 下的 veth 网卡上的IP。

* 首先，我们到 /var/run/netns目录下查看系统的network namespace，发现什么也没有。
* 然后，我们到 /var/run/docker/netns 目录下查看Docker的namespace，发现有好些。
* 于是，我们用指定位置的方式查看Docker的network namespace里的IP地址

这里要动用 **nsenter** 命令，这个命令可以进入到namespace里执行一些命令。比如

```
$ nsenter --net=/var/run/docker/netns/421bdb2accf1 ifconfig -a
```





